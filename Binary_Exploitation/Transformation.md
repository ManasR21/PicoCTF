# PicoCTF Writeup:Transformation

## **Challenge: Reverse Engineering - 16-Bit Encoding**

### **Challenge Description:**
- A Python encoding method was provided:
  ```python
  ''.join([chr((ord(flag[i]) << 8) + ord(flag[i + 1])) for i in range(0, len(flag), 2)])
  ```
- The encoded string given was:
  ```
  灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽
  ```

### **Understanding the Encoding Process:**
1. **Pairwise Combination:**
   - The flag is processed in pairs: two ASCII characters at a time.
   - For each pair `(flag[i], flag[i+1])`, the encoding process is:
     - Convert the first character to its ASCII value and **left-shift by 8** (equivalent to multiplying by 256).
     - Add the ASCII value of the second character.
     - Convert the result back to a Unicode character using `chr()`.

2. **Why Use 16 Bits?**
   - Each Unicode character in Python can represent a 16-bit value.
   - By combining two 8-bit ASCII characters into one 16-bit value, the result is a single Unicode character.

3. **Decoding Process:**
   - Reverse the process by splitting each Unicode character back into two ASCII characters:
     - **Right-shift by 8** to get the first character.
     - **Bitwise AND with 0xFF** to get the second character.
     - Convert back to characters using `chr()`.

4. **Python Decoding Code:**
   ```python
   encoded = '灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽'
   decoded = ''
   for char in encoded:
       num = ord(char)
       decoded += chr(num >> 8)
       decoded += chr(num & 0xFF)
   print(decoded)
   ```

5. **Decoded Flag:**
   - `picoCTF{16_bits_inst34d_of_8_e703b486}`

### **Why 16-Bit Worked:**
- The Unicode character addresses indicated that each character represented a combination of two ASCII characters packed into 16 bits. The encoding effectively leveraged Python's handling of Unicode to obfuscate the original string.

---

