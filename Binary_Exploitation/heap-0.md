# picoCTF Heap Overflow Challenge Write-up

## Challenge Description

The challenge involves interacting with a remote service that simulates a heap-based memory layout. The program allocates memory for some variables on the heap and provides options to interact with them, including writing to the buffer and attempting to print the flag.

## Initial Analysis

Upon connecting to the service, the initial heap state was:

```
+-------------+----------------+
[*] Address   ->   Heap Data
+-------------+----------------+
[*]   0x6173221d92b0  ->   pico
+-------------+----------------+
[*]   0x6173221d92d0  ->   bico
+-------------+----------------+
```

The variable `safe_var` was set to "bico", and the goal was to modify it to print the flag. 

## Exploit Attempt

### Attempt 1: Writing 40 'A's
```bash
Data for buffer: A*40
```
This attempt failed to modify `safe_var`.

### Attempt 2: Writing 32 'a's
```bash
Data for buffer: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```
This successfully modified the `safe_var` and allowed access to the flag.

### Reasoning

The two variables in the heap are stored at the following addresses:
- Buffer (`pico`): `0x6173221d92b0`
- Safe variable (`bico`): `0x6173221d92d0`

The difference between the two addresses is `0x20` in hexadecimal, which equals 32 in decimal. This confirms that writing exactly 32 bytes is sufficient to overflow the buffer and overwrite the adjacent `safe_var`.

### Conclusion

By exploiting the heap overflow with 32 'a's, the variable `safe_var` was successfully modified, and the flag was obtained.

### Retrieved Flag
```
picoCTF{my_first_heap_overflow_e4c92a78}
```

